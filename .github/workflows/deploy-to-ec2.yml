name: Deploy to ECR and EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    name: Deploy to ECR and EC2
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push backend image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: image-editor-backend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd backend
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Build, tag, and push frontend image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: image-editor-frontend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd frontend
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Get EC2 Instance IDs
      id: get-instances
      run: |
        BACKEND_INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=image-editor-backend" \
                    "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        FRONTEND_INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=image-editor-frontend" \
                    "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        echo "backend_instance_id=$BACKEND_INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "frontend_instance_id=$FRONTEND_INSTANCE_ID" >> $GITHUB_OUTPUT

    - name: Update Backend EC2 Instance
      if: steps.get-instances.outputs.backend_instance_id != 'None'
      env:
        INSTANCE_ID: ${{ steps.get-instances.outputs.backend_instance_id }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: image-editor-backend
      run: |
        # Send commands to update the backend container via SSM
        aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "aws ecr get-login-password --region '${{ env.AWS_REGION }}' | docker login --username AWS --password-stdin '$ECR_REGISTRY'",
            "docker pull '$ECR_REGISTRY'/'$ECR_REPOSITORY':latest",
            "docker stop backend || true",
            "docker rm backend || true",
            "docker run -d --name backend --restart always -p 8080:8080 '$ECR_REGISTRY'/'$ECR_REPOSITORY':latest",
            "systemctl restart backend || true"
          ]' \
          --output text

    - name: Update Frontend EC2 Instance
      if: steps.get-instances.outputs.frontend_instance_id != 'None'
      env:
        INSTANCE_ID: ${{ steps.get-instances.outputs.frontend_instance_id }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: image-editor-frontend
      run: |
        # Get backend private IP for environment variable
        BACKEND_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=image-editor-backend" \
                    "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].PrivateIpAddress" \
          --output text)
        
        # Send commands to update the frontend container via SSM
        aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "aws ecr get-login-password --region '${{ env.AWS_REGION }}' | docker login --username AWS --password-stdin '$ECR_REGISTRY'",
            "docker pull '$ECR_REGISTRY'/'$ECR_REPOSITORY':latest",
            "docker stop frontend || true",
            "docker rm frontend || true",
            "docker run -d --name frontend --restart always -p 3000:3000 -e BACKEND_URL=http://'$BACKEND_IP':8080 '$ECR_REGISTRY'/'$ECR_REPOSITORY':latest",
            "systemctl restart frontend || true"
          ]' \
          --output text

    - name: Wait for deployment to complete
      run: |
        echo "Waiting for deployments to complete..."
        sleep 30
        
        # Check backend health
        BACKEND_ID="${{ steps.get-instances.outputs.backend_instance_id }}"
        if [ "$BACKEND_ID" != "None" ]; then
          echo "Checking backend instance health..."
          aws ec2 describe-instance-status --instance-ids "$BACKEND_ID" \
            --query "InstanceStatuses[0].InstanceStatus.Status" --output text
        fi
        
        # Check frontend health
        FRONTEND_ID="${{ steps.get-instances.outputs.frontend_instance_id }}"
        if [ "$FRONTEND_ID" != "None" ]; then
          echo "Checking frontend instance health..."
          aws ec2 describe-instance-status --instance-ids "$FRONTEND_ID" \
            --query "InstanceStatuses[0].InstanceStatus.Status" --output text
        fi